# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, B2W Digital
# This file is distributed under the same license as the Asyncworker
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Asyncworker \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-09 09:15-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../userguide/backends.rst:2
msgid "Backends"
msgstr ""

#: ../../userguide/backends.rst:4
msgid ""
"O asyncworker suporte alguns backends diferentes. Por backend entende-se "
"a origem do estímulo que será processado pelo seu worker, ou mais "
"específicamente, por um handler do seu worker."
msgstr ""

#: ../../userguide/backends.rst:8
msgid "Atualmente o projeto suporta as seguintes backends:"
msgstr ""

#: ../../userguide/backends.rst:10
msgid "`RabbitMQ`_: Consumo de mensagens AMQP;"
msgstr ""

#: ../../userguide/backends.rst:11
msgid ""
"`Server Side Events`_: Possibilidade de eventos de um endpoint que "
"implementa Server Side Events;"
msgstr ""

#: ../../userguide/backends.rst:12
msgid "`HTTP`_: Possibilidade de receber dados via requisições HTTP"
msgstr ""

#~ msgid ""
#~ "`RabbitMQ`_: Somente leitura de mensagens. "
#~ "A implementação de publicação de "
#~ "mensagens será feita no #9;"
#~ msgstr ""

#~ msgid ""
#~ "`Server Side Events`_: Possibilidade de "
#~ "eventos de um endpoint que emite "
#~ "implementa Server Side Events."
#~ msgstr ""

#~ msgid "`HTTP`_: Possibilidade de receber dados via requisições HTTP"
#~ msgstr ""

#~ msgid "Worker lendo dados de um RabbitMQ"
#~ msgstr ""

#~ msgid "Worker lendo dados de um endpoint Server Side Events"
#~ msgstr ""

#~ msgid "Worker lendo dados de requisições HTTP"
#~ msgstr ""

#~ msgid "`Server Side Events`_: Possibilidade de eventos de um endpoint que"
#~ msgstr ""

#~ msgid ""
#~ "implementa Server Side Events; -  "
#~ "`HTTP`_: Possibilidade de receber dados "
#~ "via requisições HTTP"
#~ msgstr ""

#~ msgid "Rodando esses códigos"
#~ msgstr ""

#~ msgid "Consumindo de uma fila no RabbitMQ"
#~ msgstr ""

#~ msgid ""
#~ "Nesse exemplo, o handler ``drain_handler()``"
#~ " recebe mensagens de ambas as filas:"
#~ " ``asgard/counts`` e ``asgard/counts/errors``."
#~ msgstr ""

#~ msgid ""
#~ "Se o handler lançar alguma exception,"
#~ " a mensagem é automaticamente devolvida "
#~ "para a fila (reject com requeue=True);"
#~ " Se o handler rodar sem erros, "
#~ "a mensagem é automaticamente confirmada "
#~ "(ack)."
#~ msgstr ""

#~ msgid "Lendo dados de um endpoint Server Side Events"
#~ msgstr ""

#~ msgid ""
#~ "Nesse exemplo, o handler ``_on_event()`` "
#~ "recebe os eventos enviados pelo "
#~ "servidor. O objeto ``events`` é sempre"
#~ " uma lista, mesmo quando estamos "
#~ "usando ``BULK_SIZE=1`` (Falaremos sobre isso"
#~ " mais a frente)"
#~ msgstr ""

#~ msgid "Recebendo dados através de requisições HTTP"
#~ msgstr ""

#~ msgid ""
#~ "Nesse exemplo, declaramos um handler "
#~ "``index``, que receberá uma instância de"
#~ " ``aiohttp.web.Request`` para cada acesso "
#~ "as rotas ``GET /`` e ``GET "
#~ "/hello``."
#~ msgstr ""

#~ msgid "Rodando seu worker"
#~ msgstr ""

#~ msgid ""
#~ "Ambos os exemplos precisam de um "
#~ "``main()`` para poderem rodar. Um "
#~ "exemplo de ``main`` seria o seguinte,"
#~ " assumindo que o objeto ``app`` está"
#~ " no módulo ``myworker``:"
#~ msgstr ""

#~ msgid ""
#~ "Nesse ponto sua app já estará "
#~ "rodando e caso você seja desconectado,"
#~ " um loop ficará tentanto reconectar. "
#~ "A cada erro de conexão um log "
#~ "de exception é gerado."
#~ msgstr ""

